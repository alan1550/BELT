import time
import threading
import asyncio
import numpy as np
import matplotlib.pyplot as plt
from bleak import BleakScanner, BleakClient
from calibration_matrix import A_INV  # generated by your calibrator

# BLE parameters
UART_RX_CHAR_UUID  = "6E400003-B5A3-F393-E0A9-E50E24DCCA9E"
DEVICE_NAME_SUBSTR = "ESP32-BNO055-BLE"
SAMPLES_PER_ACTION = 90
FS = 30.0  # Sampling rate (Hz)

class ActionCollector:
    ACTIONS = [
        "tilt_left", "tilt_right",
        "tilt_forward", "tilt_backward",
        "turn_left", "turn_right"
    ]
    def __init__(self):
        self.windows = {act: [] for act in self.ACTIONS}
        self.current = None
        self.count   = 0

    def on_sample(self, accel, gyro):
        if self.current is None:
            return
        buf = self.windows[self.current]
        if len(buf) < self.count:
            acc_body  = A_INV @ accel
            gyro_body = A_INV @ gyro
            buf.append(np.hstack((acc_body, gyro_body)))

    def got_all(self, action):
        return len(self.windows[action]) >= self.count

class BLERunner:
    def __init__(self, collector):
        self.collector = collector
        self.connected = False

    def handle_rx(self, _, data: bytearray):
        try:
            parts = list(map(float, data.decode().strip().split(",")))
            if len(parts) < 6:
                return
            accel = np.array(parts[0:3])
            gyro  = np.array(parts[3:6])
            self.collector.on_sample(accel, gyro)
        except:
            return

    async def run(self):
        devices = await BleakScanner.discover(5.0)
        tgt = next((d for d in devices if d.name and DEVICE_NAME_SUBSTR in d.name), None)
        if not tgt:
            raise RuntimeError("BLE device not found")
        async with BleakClient(tgt.address) as client:
            await client.start_notify(UART_RX_CHAR_UUID, self.handle_rx)
            self.connected = True
            print(f"âœ… Connected to {tgt.name}")
            while not threading.current_thread().stopped:
                await asyncio.sleep(0.1)

    def start(self):
        t = threading.Thread(target=lambda: asyncio.run(self.run()), daemon=True)
        t.stopped = False
        t.start()
        return t

def plot_action(action, data):
    arr = np.array(data)
    t   = np.arange(len(data)) / FS

    accel = arr[:, :3]
    gyro  = arr[:, 3:6]
    accel_detrended = accel - np.mean(accel, axis=0)

    plt.figure(figsize=(12, 4))
    plt.subplot(1,2,1)
    plt.plot(t, accel_detrended[:,0], label="ax")
    plt.plot(t, accel_detrended[:,1], label="ay")
    plt.plot(t, accel_detrended[:,2], label="az")
    plt.title(f"{action.title()} â€” Accel (detrended)")
    plt.xlabel("Time (s)")
    plt.ylabel("Î”a")
    plt.legend(); plt.grid(True)

    plt.subplot(1,2,2)
    plt.plot(t, gyro[:,0], label="gx")
    plt.plot(t, gyro[:,1], label="gy")
    plt.plot(t, gyro[:,2], label="gz")
    plt.title(f"{action.title()} â€” Gyro")
    plt.xlabel("Time (s)")
    plt.ylabel("Ï‰")
    plt.legend(); plt.grid(True)

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    collector = ActionCollector()
    runner    = BLERunner(collector)
    thr       = runner.start()

    print("âŒ› Waiting for BLE connection...")
    while not runner.connected:
        time.sleep(0.1)

    for action in collector.ACTIONS:
        collector.windows[action].clear()
        input(f"\nðŸŽ¬ Perform '{action.replace('_',' ')}' â€” Press Enter to start recording {SAMPLES_PER_ACTION} samples...")
        collector.current = action
        collector.count   = SAMPLES_PER_ACTION

        while not collector.got_all(action):
            if not runner.connected:
                raise RuntimeError("BLE disconnected")
            time.sleep(0.01)

        print(f"âœ… Collected {SAMPLES_PER_ACTION} samples for '{action}'")
        collector.current = None
        plot_action(action, collector.windows[action])

